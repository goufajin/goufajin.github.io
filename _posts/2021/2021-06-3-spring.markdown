---
layout: post
title:  "spring官网文档解读"
category: spring
date:   2021-6-4 23:55:35 +0200
---
IoC是spring框架的核心技术，AOP是IoC的一个应用案例，spring-aop可以解决java企业应用中80%的场景。spring集成最成熟的AspectJ（aop的增强） 

## 1、IoC容器
### 1.1、Spring Ioc容器和beans
Spring Ioc即控制反转，也被称为依赖注入dependency injection (DI)，通过定义对象的依赖关系，在创建对象的时候，容器注入它的依赖，可以通过属性、构造器参数、工厂方法参数注入依赖对象。

org.springframework.beans 和 org.springframework.context 两个包是Spring Ioc容器的基础包，` BeanFactory` 接口提供一种先进地机制来管理各种类型的对象，`ApplicationContext`是BeanFactory的一个子接口，它增加如下的能力：
- 容易集成spring-aop特性
+ Message resource 处理（国际化） 
- Event应用
- 应用层面指定contexts，例如：在web应用环境中，`WebApplicationContext`
简而言之，`BeanFactory`提供结构框架和基础功能，`ApplicationContext`提供更多企业级指定的功能，`ApplicationContext`是`BeanFactory`的一个超集，接下来将使用`ApplicationContext`来描述Ioc容器

在Spring中 对象组成了应用的骨架，通过IoC管理。故Spring IoC被称作beans，即：Spring IoC容器管理应用的beans。一个bean就是一个对象，实例化、装配都是通过Spring IoC管理。反之，一个简单地bean是你应用中许多对象中的一个，他们相互依赖，通过反射来完成。
### 1.2、容器概述
这个接口`org.springframework.context.ApplicationContext`代表了Spring IoC容器，并且负责实例化、配置、装配beans。容器获得指令，什么样的对象是实例化、配置、装配通过读取配置元数据，配置元数据是xml、java注解或java代码，它让你表达组成你应用程序之间对象的依赖。

Spring提供这个`ApplicationContext`接口的一些实现类，在一个单独的应用程序中，通常是创建一个 `ClassPathXmlApplicationContext` 或 `FileSystemXmlApplicationContext`的实例，在过去的一段时间里是使用xml方式配置元数据。你也能够通过java注解或java代码的方式配置元数据。

在大多数应用场景中，清晰的用户代码是没有必要实例化一个或者更多地Spring IoC容器，例如：在web场景中，一个简单的八行样板文件是在web.xml文件中（参照1.15.4节），如果使用 Spring Tool Suite ，你也能轻松的创建样板配置通过较少的按键和敲击键盘。

下面描述了Spring是怎样高水平工作的，应用程序类和配置元数据相结合，在之后`ApplicationContext`是被创建和初始化，您有一个完全配置和可执行的系统或应用程序
[](/assets/images/container-magic.png)

#### 1.2.1. 配置元数据
在上面的图片显示，Spring IoC容器消费配置元数据，配置元数据集代表着具体的领域对象，作为开发者，告诉Spring容器实例化、配置、装配你应用程序的对象。

配置元数据是传统的提供一个简单和直觉地xml格式，之后大部分的章节将使用xml的格式来传达Spring IoC的特性。
> 注意！配置元数据不仅仅只有xml的方式，还有java的方式，目前，大多数应用都是使用基于java的配置方式。

以下将列举Spring IoC容器使用其他格式的元数据：
* 基于注解的配置：Spring2.5支持基于注解的方式配置元数据
* 基于java的配置：从Spring3.0，Spring JavaConfig项目提供许多特性，成为了Spring框架的核心。因此，你能够在应用程序的外部定义bean通过java的方式而不是xml的方式。为了使用这个新特性，看 [@Configuration](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html), [@Bean](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html), [@Import](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html), 和 [@DependsOn](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html) 注解。

Spring容器管理地Spring 配置必须有一个或者超过一个的bean定义组成。基于xml的元数据配置bean，<bean>元素在<beans>里面，基于java配置，在@Configuration类里面使用@Bean注解方法。

这些bean定义组成应用程序精确的对象，通常，你定义的服务层对象，数据访问层对象（DAOs），展现层对象如Struts Action实例，基础设施对象如Hibernate SessionFactories, JMS Queues等等。通常，在容器里面，没有细腻度的配置领域对象。因为它通常是DAOs和业务逻辑创建和加载领域对象（这就是DO、DTO、PO的由来吧）,然而，你也能使用Spring集成的AspectJ注入对象.[ Using AspectJ to dependency-inject domain objects with Spring.

](https://docs.spring.io/spring-framework/docs/5.2.4.RELEASE/spring-framework-reference/core.html#aop-atconfigurable)。

如下展示了基于xml配置元数据的方式：
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="..." class="...">  1,2
        <!-- collaborators and configuration for this bean go here -->
    </bean>

    <bean id="..." class="...">
        <!-- collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions go here -->

</beans>
```
> 1、id属性是一个字符串，标识了单个的bean定义
> 2、class属性定义bean的类型，使用全限定类名

id的值也是可以引用到协作的bean，这个例子没有显示引用到协作的bean，更多地看依赖[Dependencies](https://docs.spring.io/spring-framework/docs/5.2.4.RELEASE/spring-framework-reference/core.html#beans-dependencies)

#### 1.2.2.实例化容器
`ApplicationContext`构造器参数接收一个或者多个字符串的路径参数，容器加载配置元数据来自多样化地外部资源，例如：本地文件系统、java CLASSPATH等等。
```
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");
```
> 在之后关于Spring IoC容器的学习，你可能想要了解关于Spring [Resource的抽象](https://docs.spring.io/spring-framework/docs/5.2.4.RELEASE/spring-framework-reference/core.html#resources)，它提供了一个便利的机制读取一个输入流来自locations定义的一个URI语法。特别地，Resource path通常构造应用上下文，作为描述在[Application Contexts and Resource Paths](https://docs.spring.io/spring-framework/docs/5.2.4.RELEASE/spring-framework-reference/core.html#resources-app-ctx)

下面的例子显示服务层对象（services.xml）配置文件
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- services -->

    <bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl">
        <property name="accountDao" ref="accountDao"/>
        <property name="itemDao" ref="itemDao"/>
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions for services go here -->

</beans>
```
下面的例子显示数据访问层对象（daos.xml）
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="accountDao"
        class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao">
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>

    <bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao">
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions for data access objects go here -->

</beans>
```
以上的例子，通过ref表达了bean直接的依赖关系

##### 组成基于XML配置元数据
bean的定义可以跨域多个xml，这通常是有用。每一个单独的xml文件配置代表着一个逻辑层或者一个模块在你的应用中。

你能够使用应用上下文构造器加载来自多个的XML文件的bean定义，构造器获得多Resource定位。二者则一的，使用一个或者多个<import/>元素加载bean定义来自其他文件，具体如下：
```
<beans>
    <import resource="services.xml"/>
    <import resource="resources/messageSource.xml"/>
    <import resource="/resources/themeSource.xml"/>

    <bean id="bean1" class="..."/>
    <bean id="bean2" class="..."/>
</beans>
```
之上的例子，额外的bean定义加载来自三个文件services.xml, messageSource.xml, 和 themeSource.xml。在<beans/>元素下的所有的bean都被导入，必须验证xml bean定义，根据Spring Schema。
> 这是可能的，但是不推荐，引用文件在父类目录使用相对`../`路径，特别的，这个也是不推荐的`classpath:`URLs,例如：`classpath:../services.xml`,在运行的时候会选择最近的classpath根和查找在它的父目录，Classpath改变可能导致选择的目录错误。
> 推荐你使用全限定资源定位替代相对路径，例如：`file:C:/config/services.xml` 或 `classpath:/config/services.xml`，然而，你能结合你的应用配置绝对路径，例如：`${…​}`，这种方式在运行时是被替换的。

#### 1.2.3. 使用容器
`ApplicationContext`是一个高级工厂接口，它维护不同bean的登记和它们的依赖关系。使用这个方法`T getBean(String name, Class<T> requiredType)`，你能够取回你的bean的一个实例。

`ApplicationContext`这个接口让你读bean定义和访问它们，如下所示：
```
// create and configure beans
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");

// retrieve configured instance
PetStoreService service = context.getBean("petStore", PetStoreService.class);

// use configured instance
List<String> userList = service.getUsernameList();
```
一个最灵活多变的接口`GenericApplicationContext`结合读代理，例如用`XmlBeanDefinitionReader`读取xml文件bean定义，如下所示：
```
GenericApplicationContext context = new GenericApplicationContext();
new XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml");
context.refresh();
```
你能够混合相匹配诸如读代理在相同的`ApplicationContext`，读bean定义从不同的来源。

你能够使用`getBean`方法取回你的实例，这个接口`ApplicationContext`也有一些其他的方法对于取回实例。但是，理想的做法，你的应用代码绝不应该直接使用它。确实，你的应用代码不应该根本地调用`getBean()`这个方法，且在Spring APIs根本没有依赖。例如：Spring集成web框架提供依赖注入对多web框架组件，诸如，作为控制器、JSF管理bean，让你声明依赖在指定的bean通过元数据（例如：自动注入注解@autowire）

### 1.3. Bean 概述
Spring IoC 容器管理一个或多个bean，用你提供的配置元数据创建bean（例如：元数据格式是XML <bean/>定义 ）

在容器里面，这些bean定义是被描述作为`BeanDefinition` 对象。包含如下的信息：
- 全限定类名，通常，bean的定义精确的实现类
+ bean行为配置元素，bean的状态是在容器中（scope,生命周期回调,等等）
* bean的工作需要引用其他bean，引用也是被其他合作者或依赖者调用。
- 其他地配置在新创建的对象，例如：池的大小或者连接数据在一个bean，管理一个连接池。
元数据转换到一个properties制造每一个bean定义，下面的表显示这个 properties
 属性|翻译在|
 --|:--:|
 Class|实例化ben（后续加上）| 
 Name|命名bean|
 Scope|bean的域|
 Constructor arguments|依赖注入|
 Properties|依赖注入|
 Autowiring mode|装配合作者|
 Lazy initialization mode|懒实例化beans|
 Initialization method|初始化回调|
 Destruction method|销毁回调|   